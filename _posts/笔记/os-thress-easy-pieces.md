#冯·诺依曼（Von Neumann）计算模型: 处理器从内存中获取一条指令，对其进行解码，然后执行它（如两个数相加、访问内存、检查条件、跳转到函数等）。完成这条指令后，处理器继续执行下一条指令，依此类推，直到程序最终完成

程序除了要能运行，还要关注其他方面，OS 关注的是系统的易于使用。
- 操作系统如何将资源虚拟化是实现易于使用的手段

虚拟化CPU：在用户角度，好像每个程序背后都有一个处理器，因此让多个程序“同时”运行
- 一个处理器，如何运行多个程序？

虚拟化内存：表现为每个正在运行的程序都有自己的私有内存，而不是与其他正在运行的程序共享相同的物理内存
- 现代机器提供的物理内存模型非常简单: 内存就是一个字节数组。写入和读出内存数据，需要指定一个地址。
- 每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。

并发：OS上的调度，多线程编程
- 如何构建正确的并发程序？操作系统需要什么原语？硬件应该提供哪些机制？我们如何利用它们来解决并发问题？

持久性：文件系统是操作系统的一部分，负责管理持久的数据。
- 持久性需要哪些技术才能正确地实现？需要哪些机制和策略才能高性能地实现？面对硬件和软件故障，可靠性如何实现？

OS做了什么？
- 它取得 CPU、内存或磁盘等物理资源，并对它们进行虚拟化。它处理与并发相关的问题。它持久地存储文件。
- 目标：
    - 高性能：最小化操作系统的开销
    - 保护：确保一个程序的恶意或偶然的不良行为不会损害其他程序，隔离机制
    - 可靠性：必须不间断运行

**操作系统的历史**：TODO



 操作系统导论-Three-Easy-Pieces
## Part I: 虚拟化
### 进程抽象
**关键问题：如何提供有许多 CPU 的假象？**
- **时分复用**：并发的运行多个进程，每个进程都运行一个时间片，在时间片结束后，切换到另一个进程

进程：操作系统提供的关于运行中的程序的抽象。进程在每时每刻都有一个确定的状态：
- 内存
- 寄存器


进程状态：
- 运行
- 就绪
- 阻塞
![process state](/images/os-thress-easy-pieces/image.png)


### 内存虚拟化

## Part II: 并发
### 锁

### 条件变量

### 基于事件的并发


## Part III: 持久化

### IO设备、磁盘